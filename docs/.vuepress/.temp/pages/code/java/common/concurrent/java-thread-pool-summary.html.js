export const data = JSON.parse("{\"key\":\"v-95c0b698\",\"path\":\"/code/java/common/concurrent/java-thread-pool-summary.html\",\"title\":\"Java 线程池详解\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"Java 线程池详解\",\"date\":\"2020-08-21T00:00:00.000Z\",\"category\":[\"Java\"],\"tag\":[\"Java并发\"],\"summary\":\"一 使用线程池的好处\\r\\\" 池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。\\\" 线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。 这里借用《Java 并发编程的艺术》提到的来说一\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://vuepress-theme-hope-v2-demo.mrhope.site/code/java/common/concurrent/java-thread-pool-summary.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"咖飞的博客\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"Java 线程池详解\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:image\",\"content\":\"https://vuepress-theme-hope-v2-demo.mrhope.site/\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"meta\",{\"name\":\"twitter:image:alt\",\"content\":\"Java 线程池详解\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"Java并发\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2020-08-21T00:00:00.000Z\"}]]},\"excerpt\":\"\",\"headers\":[{\"level\":2,\"title\":\"一 使用线程池的好处\",\"slug\":\"一-使用线程池的好处\",\"children\":[]},{\"level\":2,\"title\":\"二 Executor 框架\",\"slug\":\"二-executor-框架\",\"children\":[{\"level\":3,\"title\":\"2.1 简介\",\"slug\":\"_2-1-简介\",\"children\":[]},{\"level\":3,\"title\":\"2.2 Executor 框架结构(主要由三大部分组成)\",\"slug\":\"_2-2-executor-框架结构-主要由三大部分组成\",\"children\":[]},{\"level\":3,\"title\":\"2.3 Executor 框架的使用示意图\",\"slug\":\"_2-3-executor-框架的使用示意图\",\"children\":[]}]},{\"level\":2,\"title\":\"三 (重要)ThreadPoolExecutor 类简单介绍\",\"slug\":\"三-重要-threadpoolexecutor-类简单介绍\",\"children\":[{\"level\":3,\"title\":\"3.1 ThreadPoolExecutor 类分析\",\"slug\":\"_3-1-threadpoolexecutor-类分析\",\"children\":[]},{\"level\":3,\"title\":\"3.2 推荐使用 ThreadPoolExecutor 构造函数创建线程池\",\"slug\":\"_3-2-推荐使用-threadpoolexecutor-构造函数创建线程池\",\"children\":[]}]},{\"level\":2,\"title\":\"四 ThreadPoolExecutor 使用+原理分析\",\"slug\":\"四-threadpoolexecutor-使用-原理分析\",\"children\":[{\"level\":3,\"title\":\"4.1 示例代码:Runnable+ThreadPoolExecutor\",\"slug\":\"_4-1-示例代码-runnable-threadpoolexecutor\",\"children\":[]},{\"level\":3,\"title\":\"4.2 线程池原理分析\",\"slug\":\"_4-2-线程池原理分析\",\"children\":[]},{\"level\":3,\"title\":\"4.3 几个常见的对比\",\"slug\":\"_4-3-几个常见的对比\",\"children\":[]},{\"level\":3,\"title\":\"4.4 加餐:Callable+ThreadPoolExecutor示例代码\",\"slug\":\"_4-4-加餐-callable-threadpoolexecutor示例代码\",\"children\":[]}]},{\"level\":2,\"title\":\"五 几种常见的线程池详解\",\"slug\":\"五-几种常见的线程池详解\",\"children\":[{\"level\":3,\"title\":\"5.1 FixedThreadPool\",\"slug\":\"_5-1-fixedthreadpool\",\"children\":[]},{\"level\":3,\"title\":\"5.2 SingleThreadExecutor 详解\",\"slug\":\"_5-2-singlethreadexecutor-详解\",\"children\":[]},{\"level\":3,\"title\":\"5.3 CachedThreadPool 详解\",\"slug\":\"_5-3-cachedthreadpool-详解\",\"children\":[]}]},{\"level\":2,\"title\":\"六 ScheduledThreadPoolExecutor 详解\",\"slug\":\"六-scheduledthreadpoolexecutor-详解\",\"children\":[{\"level\":3,\"title\":\"6.1 简介\",\"slug\":\"_6-1-简介\",\"children\":[]},{\"level\":3,\"title\":\"6.2 运行机制\",\"slug\":\"_6-2-运行机制\",\"children\":[]},{\"level\":3,\"title\":\"6.3 ScheduledThreadPoolExecutor 执行周期任务的步骤\",\"slug\":\"_6-3-scheduledthreadpoolexecutor-执行周期任务的步骤\",\"children\":[]}]},{\"level\":2,\"title\":\"七 线程池大小确定\",\"slug\":\"七-线程池大小确定\",\"children\":[]},{\"level\":2,\"title\":\"八 参考\",\"slug\":\"八-参考\",\"children\":[]},{\"level\":2,\"title\":\"九 其他推荐阅读\",\"slug\":\"九-其他推荐阅读\",\"children\":[]}],\"readingTime\":{\"minutes\":29.74,\"words\":8921},\"filePathRelative\":\"code/java/common/concurrent/java-thread-pool-summary.md\",\"localizedDate\":\"2020年8月21日\"}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
