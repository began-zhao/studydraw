"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@vuepress/core"),t=require("chokidar"),a=require("@vuepress/shared");const n=new(require("vuepress-shared").Logger)("vuepress-plugin-blog2"),o=(e,t)=>{const a={};return Object.keys({"/":{},...t.options.locales}).forEach((e=>{a[e]=[]})),t.pages.filter(e).forEach((e=>{a[e.pathLocale].push(e)})),a},r=(t,o,r,p=!1)=>{const{category:i=[],slugify:s=(e=>e.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase())}=o;return Promise.all(i.map((async({key:o,getter:i,sorter:g=(()=>-1),path:l="/:key/",layout:c="Layout",frontmatter:y=(()=>({})),itemPath:u="/:key/:name/",itemLayout:f="Layout",itemFrontmatter:h=(()=>({}))},m)=>{if("string"!=typeof o||!o)return n.error(`Invalid 'key' option ${o} in 'category[${m}]'`),null;if("function"!=typeof i)return n.error(`Invalid 'getter' option in 'category[${m}]', it should be a function!`),null;t.env.isDebug&&n.info(`Generating ${o} category.\n`);const d={},k=[],_="function"==typeof u?u:e=>(u||"").replace(/:key/g,s(o)).replace(/:name/g,s(e));for(const u in r){if(l){const r=`${u}${a.removeLeadingSlash(l.replace(/:key/g,s(o)))}`,i=await e.createPage(t,{path:r,frontmatter:{...y(u),blog:{type:"category",key:o},layout:c}}),g=t.pages.findIndex((({path:e})=>e===r));-1===g?t.pages.push(i):t.pages[g].key!==i.key&&(t.pages.splice(g,1,i),p&&n.warn(`Overiding existed path ${r}`)),k.push(i.key),d[u]={path:i.path,map:{}}}else d[u]={path:"",map:{}};const{map:m}=d[u],$={};for(const s of r[u]){const r=i(s);for(const i of r){if(!m[i]){const r=_(i);if(r){const s=`${u}${a.removeLeadingSlash(r)}`,g=await e.createPage(t,{path:`${u}${a.removeLeadingSlash(r)}`,frontmatter:{...h(i,u),blog:{type:"category",name:i,key:o},layout:f}}),l=t.pages.findIndex((({path:e})=>e===s));-1===l?t.pages.push(g):t.pages[l].key!==g.key&&(t.pages.splice(l,1,g),p&&n.warn(`Overiding existed path ${s}`)),k.push(g.key),m[i]={path:g.path,keys:[]}}else m[i]={path:"",keys:[]};$[i]=[]}$[i].push(s)}}for(const e in $)m[e].keys=$[e].sort(g).map((({key:e})=>e));if(t.env.isDebug){let e=`Route ${u} in ${o} cateogry:\n`;for(const t in m){const{path:a,keys:n}=m[t];e+=`name: ${t}; ${a?`path: ${a}; `:""}items: ${n.length}\n`}n.info(e)}}return{key:o,map:d,pageKeys:k}}))).then((async e=>{const a={},o=[];return e.filter((e=>null!==e)).forEach((({key:e,map:t,pageKeys:n})=>{a[e]=t,o.push(...n)})),await t.writeTemp("blog/category.js",`export const categoryMap = ${JSON.stringify(a)}\n\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept()\n  if (__VUE_HMR_RUNTIME__.updateBlogCategory) {\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap)\n  }\n}\n\nif (import.meta.hot) {\n  import.meta.hot.accept(({ categoryMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap)\n  })\n}\n`),t.env.isDebug&&n.info("All categories generated."),o}))},p=(t,o,r,p=!1)=>{const{type:i=[],slugify:s=(e=>e.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase())}=o;return Promise.all(i.map((async({key:o,sorter:i=(()=>-1),filter:g=(()=>!0),path:l="/:key/",layout:c="Layout",frontmatter:y=(()=>({}))},u)=>{if("string"!=typeof o||!o)return n.error(`Invalid 'key' option ${o} in 'category[${u}]'`),null;const f={},h=[];t.env.isDebug&&n.info(`Generating ${o} type.\n`);for(const u in r){const m=r[u].filter(g).sort(i).map((({key:e})=>e));if(l){const r=`${u}${a.removeLeadingSlash(s(l.replace(/:key/g,o)))}`,i=await e.createPage(t,{path:r,frontmatter:{...y(u),blog:{type:"type",key:o},layout:c}}),g=t.pages.findIndex((({path:e})=>e===r));-1===g?t.pages.push(i):t.pages[g].key!==i.key&&(t.pages.splice(g,1,i),p&&n.warn(`Overiding existed path ${r}`)),h.push(i.key),f[u]={path:i.path,keys:m},t.env.isDebug&&n.info(`Route ${u} in ${o} type: path: ${i.path}; items: ${m.length}\n`)}else f[u]={path:"",keys:m},t.env.isDebug&&n.info(`Route ${u} in ${o} type: items: ${m.length}\n`)}return{key:o,map:f,pageKeys:h}}))).then((async e=>{const a={},o=[];return e.filter((e=>null!==e)).forEach((({key:e,map:t,pageKeys:n})=>{a[e]=t,o.push(...n)})),await t.writeTemp("blog/type.js",`export const typeMap = ${JSON.stringify(a)}\n\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept()\n  if (__VUE_HMR_RUNTIME__.updateBlogType) {\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap)\n  }\n}\n\nif (import.meta.hot) {\n  import.meta.hot.accept(({ typeMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap)\n  })\n}\n`),t.env.isDebug&&n.info("All types generated."),o}))},i=a=>i=>{const{getInfo:s=(()=>({})),filter:g=(e=>Boolean(e.filePathRelative)&&!e.frontmatter.home),metaScope:l="_blog"}=a;let c=[];return i.env.isDebug&&n.info(`Options: ${a.toString()}`),{name:"vuepress-plugin-blog2",define:()=>({BLOG_META_SCOPE:l}),extendsPage:e=>{g(e)&&(e.routeMeta={...""===l?s(e):{[l]:s(e)},...e.routeMeta})},onInitialized:e=>{const t=o(g,e);return Promise.all([r(e,a,t,!0).then((e=>{c.push(...e)})),p(e,a,t,!0).then((e=>{c.push(...e)}))]).then((()=>{e.env.isDebug&&n.info("temp file generated")}))},onWatched:(i,s)=>{if(a.hotReload){const l=t.watch("pages/**/*.js",{cwd:i.dir.temp(),ignoreInitial:!0}),y=()=>{const t=[],s=o(g,i);return Promise.all([r(i,a,s).then((e=>{t.push(...e)})),p(i,a,s).then((e=>{t.push(...e)}))]).then((async()=>{const a=c.filter((e=>!t.includes(e))),o=t.filter((e=>!c.includes(e)));o.length&&(i.env.isDebug&&n.info(`New pages detected: ${o.toString()}`),await Promise.all(o.map((async t=>{await e.preparePageComponent(i,i.pages.find((({key:e})=>e===t))),await e.preparePageData(i,i.pages.find((({key:e})=>e===t)))})))),a.length&&(i.env.isDebug&&n.info(`Removing following pages: ${a.toString()}`),a.forEach((e=>{i.pages.splice(i.pages.findIndex((({key:t})=>t===e)),1)}))),(a.length||o.length)&&(await e.preparePagesComponents(i),await e.preparePagesData(i),await e.preparePagesRoutes(i)),c=t,i.env.isDebug&&n.info("temp file updated")}))};l.on("add",(()=>{y()})),l.on("change",(()=>{y()})),l.on("unlink",(()=>{y()})),s.push(l)}}}};exports.blogPlugin=i,exports.default=i;
//# sourceMappingURL=index.js.map
